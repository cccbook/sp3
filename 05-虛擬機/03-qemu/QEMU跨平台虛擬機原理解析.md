# QEMU 跨平台虛擬機原理解析

```
作者：陳鍾誠
日期：2020/6/9
```

> 說明: 本報告的節錄內容主要來源為 -- [QEMU, a Fast and Portable Dynamic Translator (PDF)](https://www.usenix.org/legacy/event/usenix05/tech/freenix/full_papers/bellard/bellard.pdf) , Fabrice Bellard.

## 前言

若您還沒使用過 QEMU，建議先看完以下這篇再繼續看本文！

* [QEMU 安裝與使用](qemuXv6.md)

## 簡介

編譯器 qemu 的初始創作者是 [Fabrice Bellard](https://bellard.org/) ，以下是他的作品網頁：

* https://bellard.org/

QEMU 是一種跨平台、跨處理器的虛擬機，可以在 x86 上模擬出 ARM 處理器的行為，也可以反過來在 ARM 上模擬出 x86 的行為。

## 方法

其主要採用技術是將 img 二進位碼指令轉換成目標平台的微指令組合，這些微指令會呼叫背後的 C 語言程式，然後採用 gcc 為工具快速的將這些微指令編譯執行。

對於 QEMU 的設計原理，Fabrice Bellard 曾經寫過一篇論文描述，該論文網址如下：

* https://www.usenix.org/legacy/event/usenix05/tech/freenix/full_papers/bellard/bellard.pdf

論文中描述了 QEMU 的指令翻譯原理，以下是其中的一個 x86 指令範例：

> addi r1,r1,-16 # r1 = r1 - 16

若我們用 qemu 在 powerPC 處理器上執行該指令時，會被翻譯成下列三條微指令：

```asm
movl_T0_r1 # T0 = r1
addl_T0_im -16 # T0 = T0 - 16
movl_r1_T0 # r1 = T0
```

論文中說第一條微指令會翻譯成下列 C 語言呼叫。

```c
void op_movl_T0_r1(void) {
  T0 = env->regs[1];
}
```

我猜測第二、三條微指令應該是翻譯成：

```c
void add_T0_im(int num) {
  T0 = env->regs[1];
  T0 = T0 + num;
  env->regs[1] = T0
}

void op_movl_T0_r1(void) {
  env->regs[1] = T0;
}
```

論文中說上述 C 語言程式中的 env 在 PowerPC 中應該對應到 32 個暫存器。

> env is a structure containing the target CPU state. The 32 PowerPC registers are stored in the array env->regs[32].

Fabrice Bellard 設計時刻意把微指令數量降得很低，該論文中說道：

> The number of micro operations is minimized without impacting the quality of the generated code much. For example, instead of generating every possible move between every 32 PowerPC registers, we just generate moves to and from a few temporary registers. These registers T0, T1, T2 are typically stored in host registers by using the GCC static register variable extension.

這樣就可以把暫存器的安排與優化等任務交給 gcc ，降低 qemu 的實作負擔。 

(改進想法：現在有 LLVM ，或許可以改翻成 LLVM IR 中間碼，然後由 llc 將中間碼轉為目標平台的指令，或者交由 lli 中間碼解譯器去執行也行)

但是為了效能更快， op_addl_T0_im() 函數把常數參數放到全域變數中的 op_param1，而不是作為參數傳入，

```c
extern int __op_param1;
void op_addl_T0_im(void)
{
T0 = T0 + ((long)(&__op_param1));
}
```

QEMU 在翻譯指令時，會動態的將《來源平台的機器指令》翻譯成《目標平台的微指令》，以下是其程式片段：


```
[...]
for(;;) {
  switch(*opc_ptr++) {
    [...]
    case INDEX_op_movl_T0_r1:
    {
      extern void op_movl_T0_r1();
      memcpy(gen_code_ptr, (char *)&op_movl_T0_r1+0, 3);
      gen_code_ptr += 3;
      break;
    }
    case INDEX_op_addl_T0_im:
    {
      long param1;
      extern void op_addl_T0_im();
      memcpy(gen_code_ptr, (char *)&op_addl_T0_im+0, 6);
      param1 = *opparam_ptr++;
      *(uint32_t *)(gen_code_ptr + 2) = param1;
      gen_code_ptr += 6;
      break;
    }
    [...]
  }
}
[...]

```

上述翻譯過程中，通常只是將 gcc 產生的目標機器碼複製到對應記憶體裏，其對應方式如下所示：

```
# movl_T0_r1
# ebx = env->regs[1]
mov 0x4(%ebp),%ebx
# addl_T0_im -16
# ebx = ebx - 16
add $0xfffffff0,%ebx
# movl_r1_T0
# env->regs[1] = ebx
mov %ebx,0x4(%ebp)
```

但是對於 addl_T0_im -16 這樣有使用到全域變數 (像是 `__op_param1`) 的指令，必須做動態重定位，dyngen 就是為此而設計的，請參考原論文：

> For most micro operations such as movl T0 r1, the host code generated by GCC is just copied. When constant parameters are used, dyngen uses the fact that relocations to op param1 are generated by GCC to patch the generated code with the runtime parameter (here it is called param1).


## Dynagen 的實作

Dynagen 的主要設計原理如以下論文原文所述：

The dyngen tool is the key of the QEMU translation process. The following tasks are carried out when running it on an object file containing micro operations:

* The object file is parsed to get its symbol table, its relocations entries and its code section. This pass depends on the host object file format (dyngen supports ELF (Linux), PE-COFF (Windows) and MACH-O (Mac OS X)).
* The micro operations are located in the code section using the symbol table. A host specific method is executed to get the start and the end of the copied code. Typically, the function prologue and epilogue are skipped.
* The relocations of each micro operations are examined to get the number of constant parameters. The constant parameter relocations are detected by the fact they use the specific symbol name op paramN.
* A memory copy in C is generated to copy the micro operation code. The relocations of the code of each micro operation are used to patch the copied code so that it is properly relocated. The relocation patches are host specific.
* For some hosts such as ARM, constants must be stored near the generated code because they are accessed with PC relative loads with a small displacement. A host specific pass is done to relocate these constants in the generated code.

When compiling the micro operation code, a set of GCC flags is used to manipulate the generation of function prologue and epilogue code into a form that is easy to parse. A dummy assembly macro forces GCC to always terminate the function corresponding to each micro
operation with a single return instruction. Code concatenation would not work if several return instructions were generated in a single micro operation.

簡而言之就是從目的檔中取出對應的指令機器碼，然後透過 《目的檔資訊》取得修改紀錄，並進行對應的修改。

必須小心特定處理器的特性，像是 ARM 的定址範圍限制之類的。

另外對 gcc 產生的碼，必須去除《前後的函數進入離開處理段落》。

還有必須考慮當一個函數有很多 return 時就不能單純用連接的方式將指令接起來等等細節！

## 其他實作細節

1 - 機器指令會被《跳曜指令》打斷分成很多《翻譯基本塊 TB》，塊與塊之間的跳轉會需要修改 CPU 狀態，才能正確進行模擬，以下是其論文原文

> 3.1 Translated Blocks and Translation Cache
> 
> When QEMU first encounters a piece of target code, it translates it to host code up to the next jump or instruction modifying the static CPU state in a way that cannot be deduced at translation time. We call these basic blocks Translated Blocks (TBs).
> 
> A 16 MByte cache holds the most recently used TBs. For simplicity, it is completely flushed when it is full.
> 
> The static CPU state is defined as the part of the CPU state that is considered as known at translation time when entering the TB. For example, the program counter (PC) is known at translation time on all targets. On x86, the static CPU state includes more data to be able to generate better code. It is important for example to know if the CPU is in protected or real mode, in user or kernel mode, or if the default operand size is 16 or 32 bits.

2 - Qemu 使用固定暫存器分配的方式，以下是其論文原文

> 3.2 Register allocation
> 
> QEMU uses a fixed register allocation. This means that each target CPU register is mapped to a fixed host register or memory address. On most hosts, we simply map all the target registers to memory and only store a few temporary variables in host registers. The allocation of the temporary variables is hard coded in each target CPU description. The advantage of this method is simplicity and portability.
> 
> The future versions of QEMU will use a dynamic temporary register allocator to eliminate some unnecessary moves in the case where the target registers are directly stored in host registers.

3 - 跳曜條件使用 lazy evaluation 的方式才不會導致效能下降太多，以下是其論文原文：

> 3.3 Condition code optimizations
> 
> Good CPU condition code emulation (eflags register on x86) is a critical point to get good performances. QEMU uses lazy condition code evaluation: instead of computing the condition codes after each x86 instruction, it just stores one operand (called CC SRC), the result (called CC DST) and the type of operation (called CC OP). For a 32 bit addition such as R = A + B, we have:

```
CC_SRC=A
CC_DST=R
CC_OP=CC_OP_ADDL
```

> Knowing that we had a 32 bit addition from the constant stored in CC OP, we can recover A, B and R from CC SRC and CC DST. Then all the corresponding condition codes such as zero result (ZF), non-positive result (SF), carry (CF) or overflow (OF) can be recovered if
they are needed by the next instructions.
> The condition code evaluation is further optimized at translation time by using the fact that the code of a complete TB is generated at a time. A backward pass is done on the generated code to see if CC OP, CC SRC or CC DST are not used by the following code. At the end of TB we consider that these variables are used. Then we delete the assignments whose value is not used in the following code.

4 - TB 區塊之間的連接方式，若跳轉時該區塊還沒載入，則先載入後再跳轉！

> 3.4 Direct block chaining
> 
> After each TB is executed, QEMU uses the simulated Program Counter (PC) and the other information of the static CPU state to find the next TB using a hash table. If the next TB has not been already translated, then a new translation is launched. Otherwise, a jump to the next TB is done.
> In order to accelerate the most common case where the new simulated PC is known (for example after a conditional jump), QEMU can patch a TB so that it jumps directly to the next one. The most portable code uses an indirect jump. On some hosts (such as x86 or PowerPC), a branch instruction is directly patched so that the block chaining has no overhead.

5 - 使用 mmap() 來實作 MMU 記憶體管理單元的模擬 (將 MMU 軟體化)

> 3.5 Memory management
> 
> For system emulation, QEMU uses the mmap() system call to emulate the target MMU. It works as long as the emulated OS does not use an area reserved by the host OS.2
> In order to be able to launch any OS, QEMU also supports a software MMU. In that mode, the MMU virtual to physical address translation is done at every memory access. QEMU uses an address translation cache to speed up the translation.
> To avoid flushing the translated code each time the MMU mappings change, QEMU uses a physically indexed translation cache. It means that each TB is indexed with its physical address.
> When MMU mappings change, the chaining of the TBs is reset (i.e. a TB can no longer jump directly to another one) because the physical address of the jump targets may change.

6 - 如何處理《自我修改》的程式碼！ (這得令修改過的 TB 失效並重新翻譯) 

> 3.6 Self-modifying code and translated code invalidation
> 
> On most CPUs, self-modifying code is easy to handle because a specific code cache invalidation instruction is executed to signal that code has been modified. It suffices to invalidate the corresponding translated code.
> However on CPUs such as the x86, where no instruction cache invalidation is signaled by the application when code is modified, self-modifying code is a special challenge . When translated code is generated for a TB, the corresponding host page is write protected if it is not already read-only. If a write access is made to the page, then QEMU invalidates all the translated code in it and reenables write accesses to it.
> Correct translated code invalidation is done efficiently by maintaining a linked list of every translated block contained in a given page. Other linked lists are also maintained to undo direct block chaining.
> When using a software MMU, the code invalidation is more efficient: if a given code page is invalidated too often because of write accesses, then a bitmap representing all the code inside the page is built. Every store into that page checks the bitmap to see if the code really needs to be invalidated. It avoids invalidating the code when only data is modified in the page.

7 - 例外處理 -- 使用 longjump() 跳到例外處理程式

> 3.7 Exception support
> 
> longjmp() is used to jump to the exception handling code when an exception such as division by zero is encountered. When not using the software MMU, host signal handlers are used to catch the invalid memory accesses.
> QEMU supports precise exceptions in the sense that it is always able to retrieve the exact target CPU state at the time the exception occurred. Nothing has to be done for most of the target CPU state because it is explicitly stored and modified by the translated code. The target CPU state S which is not explicitly stored (for example the current Program Counter) is retrieved by re-translating
the TB where the exception occurred in a mode where S is recorded before each translated target instruction. The host program counter where the exception was raised is used to find the corresponding target instruction and the state S. 

8 - 硬體中斷模擬 : 

> 3.8 Hardware interrupts
> 
> In order to be faster, QEMU does not check at every TB if an hardware interrupt is pending. Instead, the user must asynchronously call a specific function to tell that an interrupt is pending. This function resets the chaining of the currently executing TB. It ensures that the execution will return soon in the main loop of the CPU emulator. Then the main loop tests if an interrupt is pending and handles it.

這段有點看不懂，硬體中斷等待期間，必須由使用者呼叫一個《非同步的函數》 (the user must asynchronously call a specific function to tell that an interrupt is pending) ??

9 - 使用者模式模擬 : 使用者模式不需要《軟體 MMU》，因為那是 OS 負責的。

> 3.9 User mode emulation
> 
> QEMU supports user mode emulation in order to run a Linux process compiled for one target CPU on another CPU. At the CPU level, user mode emulation is just a subset of the full system emulation. No MMU simulation is done because QEMU supposes the user memory mappings are handled by the host OS. QEMU includes a generic Linux system call converter to handle endianness issues and 32/64 bit conversions. Because QEMU supports exceptions, it emulates the target signals exactly. Each target thread is run in one host thread.

## 論文結尾

該論文結尾另外討論了下列主題

* 移植 QEMU 需要移植的程式碼為哪些？
* QEMU 的效能評估！ (大約比原生機器碼執行慢四倍)

結論：作者認為寫論文當時 QEMU 已經達到《可日常使用》的程度，但對於《各種平台的移植、除錯模式的支援、軟體 MMU 的效能改進》等都還有不少事情要做！



