# 組譯器

組譯器的主要功能，是將組合語言轉換為機器碼。在本文中，我們將說明組譯器的工作原理。

## 組譯器簡介

組譯器乃是將組合語言轉換為目的檔的工具。有時，組譯器也會直接將組合語言轉換為可執行檔。因此，組譯器是組合語言程式師所使用的主要工具。

下圖顯示了組譯器的運作過程，當程式師寫完組合語言程式後，可以利用組譯器，將該程式轉換為二進位的目的檔，然而，由於二進位的表示法過於冗長，通常我們在範例中會改寫為 16 進位，以方便讀者閱讀。

![](./img/cpu0assembler.png)

以上範例是一個簡單的 CPU0 組合語言程式，指令 LD R1, B 是將記憶體變數 B 的值載入到暫存器 R1 當中，而 ST R1, A 則是將暫存器 R1 儲存到記憶體變數 A 當中，整個程式的功能相當於執行 C 語言中的 A = B 指令。

![](./img/cpu0asm1.png)

## 轉譯成目的碼

當上述組合語言程式被組譯時，程式中的指令會被轉換為目的碼。以下範例該程式轉換成目的碼之後的結果。

目的碼 (絕對定址版) 當中，指令 LD R1, B 被轉譯為 00100010，ST R1, A 則被轉譯為 0110000C，RET 被轉譯為 2C000000。接著，資料宣告的指令 A RESW 1 被轉譯為 00000000，但是 B WORD 29 這個指令卻被轉譯為目的碼
0000001D。讀到此處，讀者必然心中有所疑問，這些轉譯動作是如何進行的呢？

![](./img/cpu0asm1obj.png)

要能理解目的碼的轉譯過程，最關鍵的部分還是必須回到指令編碼表上，由於以上範例為 CPU0 的組合語言，您必須閱讀下列文件才能理解該處理器的架構與指令集。

* [CPU0 處理器 (PDF)](./cpu0/cpu0.pdf)

根據 CPU0 的指令表，我們可以看出 LD 指令的 OP 欄位編碼為 00，ST 的編碼為 01，而且兩者均為 L 型格式。接著從格式圖中，我們可以看到 L 型指令的格式，包含 OP、Ra、Rb、Cx 等四者的位置圖。

舉例而言，在指令 LD R1, B 中，指令 LD 被編為 16 進位的 00、R1 被編為 1，因此，整個指令應該被編為 001XXXXX，但後續的編碼可能有兩種方法。第一種是
採用絕對定址法，第二種是採用相對定址法。

採用絕對定址法時，LD R1, B 其實應該改寫為 LD R1, [R0+B] 才對。根據 L 型指令的格式 (OP Ra, Rb, Cx)，可看出下列對應關係 (OP=LD、Ra=R1、Rb=R0、Cx=B)。

由於 R0 永遠為 0，於是組譯器只要在 Cx 的部分填入變數 B 的位址 0010 就行了。

下圖顯示了指令 LD R1, B 與目的碼 00100010 之間的對應方式。同理，ST R1,A 也就被編為 0110000C，請讀者自行嘗試編碼看看。

![](./img/cpu0encode1.png)

然而，使用絕對定址法有很大的缺點，因為 Cx 欄位的大小只有 16 個 bits，而且採用二補數的格式，最多只能定址 -32768～32767 的範圍。但是既然絕對位址不可能有負數，於是就只剩 0～32767 的部分可用。如果我們堅持採用絕對定
址法，那就必須限制這些變數都必須被放在 0～32K 的範圍內，這是相當不合理的。

> 註：對於一般的 32 位元電腦而言，定址範圍通常可以達到 4G，這將是 Cx 定址範圍的 65536 倍。

一個比較好的方式是利用相對定址法編碼，但是要相對於哪一個暫存器呢？一種常見的方式是採用相對於程式計數器 PC 的方式。其原因是指令與被載入的資料定義通常在同一個程式當中，因此，兩者之間的距離不會太大，只要不超過 Cx 的
範圍，就可以使用相對於 PC 的定址法。在實務上，很少單一程式模組的大小會超過 32K，因此，相對於 PC 的定址法是不錯的選擇。

採用相對於 PC 的定址法，LD R1, B 的指令，其實應該改寫為 LD R1, [PC+Cx] 的形式，也就是 LR R1, [R15+Cx] 才對，其中的 Cx 應設定為 B-R15，才能正確定址。所以組譯器必須在 Cx 當中放入變數 B 與 R15 的差異值，才能正確的存取變數 B。

在範例 4.2 的相對定址版目的碼當中，我們採用了相對於 PC 的定址法。舉例而言，LD R1, B 指令被編為目的碼 001F000C，其中的 F 是十六進為的 15，代表了R15 暫存器，也就是 PC。圖 4.3 顯示了我們以相對於 PC 的定址法，將指令 LD R1, B 編為目的碼的過程。

必須注意的一點是，雖然指令 LD R1, B 的位址為 0x0000，但在指令提取動作完成後，PC 已經被加上 4 了，因此圖 4.3 當中的 PC 是 0x0004，而非 0x0000。

所以，Cx 的數值將是 B-PC = 0x0010-0x0004=0x000C，於是 Cx 將被填入 000C，整個 LD R1, B 指令就被編為 001F000C 了。

根據同樣的方式，範例 4.2 中的 ST R1, A 指令，若採用絕對定址的編碼方式，將會被組譯為 0110000C，但是若採用相對於 PC 的編碼方式，將會被組譯成011F0004，請各位讀者務必自行推導出其對應方式，以便學習組譯器的編碼原理。

範例 4.2 當中的 RET 指令，其編碼方式很簡單，因為並沒有牽涉到定址的問題，於是我們根據 RET 指令的 OP 碼 2C，將指令編為 2C000000。

在範例 4.2 中，還有兩個資料變數 A 與 B，也必須被編為目的碼。資料的編碼相當簡單，只要轉換為 16 進位並且符合格式即可。於是 B WORD 29 的指令被編為 0000001D，這是由於十進位的29被轉換成目的碼後，若寫成 16 進位會是 1D，而且 CPU0 當中一個 Word 占據 4 bytes，對應到 16 進位會有 8 個數字。所以，B WORD 29 才會被組譯成 00 00 00 1D。