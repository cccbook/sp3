# 第 6 章 -- 虛擬內存


## 什麼不是虛擬內存


虛擬內存通常被天真地討論為一種擴展RAM的方式，即使用硬盤作為額外的、較慢的系統內存。也就是說，一旦你的系統耗盡了內存，它就會流到作為“虛擬”內存的硬盤上。


在現代操作系統中，這通常稱為交換空間，因為將未使用的內存部分交換到磁盤以釋放主內存(記住，程序只能從主內存執行)。


實際上，將內存交換到磁盤的能力是一項重要的功能，但正如您將看到的，它不是虛擬內存的目的，而是一個非常有用的副作用!


## 什麼是虛擬內存

虛擬內存就是利用地址空間。


處理器的地址空間是指它在加載和存儲到內存時可以使用的可能地址的範圍。地址空間受寄存器寬度的限制，因為我們知道要加載地址，需要發出一個裝載指令，其中包含存儲在寄存器中的地址。例如，32位寬的寄存器可以容納從0x00000000到0xFFFFFFF範圍內的地址。2 ^ 32 = 4 gb,所以一個32位處理器可以加載或存儲多達4 gb的內存。


### 64位計算

新的處理器通常都是64位的，顧名思義，它的寄存器是64位的。作為練習，您應該計算出這些處理器可用的地址空間(提示:它很大!)


64位計算對於使用更小的位寬處理器確實有一些權衡。在64位模式下編譯的每個程序都需要8字節的指針，這會增加代碼和數據的大小，從而影響指令和數據緩存的性能。然而，64位處理器往往有更多的寄存器，這意味著當編譯器在寄存器壓力下時，將臨時變量保存到內存的需要更少。


### 標准地址

雖然64位處理器有64位寬的寄存器，但是系統通常不會實現所有64位的尋址——實際上不可能加載或存儲所有16艾字節的理論物理內存!


因此，大多數體系結構定義了一個未實現的地址空間區域，處理器認為該區域不可用。x86-64和Itanium都定義了地址中最重要的有效位，然後必須經過符號擴展(請參閱“符號擴展”一節)才能創建有效地址。這樣做的結果是，總地址空間有效地分為兩個部分，一個上部分和一個下部分，中間的地址被認為是無效的。圖6.1“規範地址的說明”對此進行了說明。有效地址稱為規範地址(無效地址是非規範地址)。


> 圖6.1。規範地址的說明

![](http://www.bottomupcs.com/chapter05/figures/canonical.png)

>通過定義一個最重要的位(必須經過符號擴展才能創建完整地址)，有效地將地址空間劃分為上下部分，處理器認為中間地址無效。


處理器最重要的位值通常可以通過使用信息指令查詢處理器本身來找到。雖然確切的值是依賴於實現的，但是典型的值是48;提供248 = 256 TiB的可用地址空間。


這樣減少可能的地址空間意味著，處理器和相關組件中的尋址邏輯的所有部分可以大大節省，因為它們知道不需要處理完整的64位地址。由於實現將上位定義為簽名擴展的，所以這就防止了使用這些位存儲或標記附加信息的可移植操作系統，如果實現希望在將來實現更多的地址空間，就可以確保兼容性。


### 使用地址空間

與操作系統的大多數組件一樣，虛擬內存充當地址空間和系統中可用的物理內存之間的抽像。這意味著，當程序使用一個地址時，該地址不會引用內存中實際物理位置中的位。


為此，我們說程序使用的所有地址都是虛擬的。操作系統跟蹤虛擬地址以及如何將它們分配給物理地址。當程序從一個地址進行加載或存儲時，處理器和操作系統一起工作，將這個虛擬地址轉換為系統內存芯片中的實際地址。


## 頁

總地址空間劃分為各個頁面。頁面可以有許多不同的大小;通常是4千磅左右，但這並不是一個嚴格的規則，它們可以大得多，但一般不會小得多。頁面是操作系統和硬件能夠處理的最小內存單元。


此外，每個頁面都有操作系統設置的一些屬性。通常，這些權限包括當前頁面的讀、寫和執行權限。例如，操作系統通常可以用可執行標記標記進程的代碼頁，處理器可以選擇在沒有這個位集的情況下不執行來自頁面的任何代碼。


> 圖6.2。虛擬內存頁面

![](http://www.bottomupcs.com/chapter05/figures/page.png)

## 頁


此時，程序員可能會想，他們可以使用malloc或類似的調用，輕松地分配比4kib小得多的少量內存。這個堆內存實際上是由頁面大小的分配支持的，malloc實現以一種高效的方式為您劃分和管理這些分配。


## 物理內存

正如操作系統將可能的地址空間劃分為頁面一樣，它將可用的物理內存劃分為框架。框架只是與系統頁面大小相同的大塊物理內存的常規名稱。


操作系統保持一個框架表，它是所有可能的物理內存頁面的列表，如果它們是免費的(可分配的)或不。當將內存分配給進程時，它被標記為在框架表中使用。這樣，操作系統就可以跟蹤所有內存分配。


操作系統如何知道哪些內存可用?BIOS在初始化過程中向操作系統傳遞有關內存位置、數量、屬性等信息。


## Pages + Frames = Page Tables

操作系統的工作是跟蹤哪個虛擬頁指向哪個物理幀。這些信息保存在一個頁表中，以其最簡單的形式，可以只是一個表，其中每行包含其關聯的框架——這被稱為線性頁表。如果你要使用這個簡單的系統,一個32位的地址空間和4簡約頁面可能會有1048576頁的跟蹤頁表(2<sup>32</sup>÷4096);因此，該表的長度將為1048576個條目，以確保我們始終能夠將虛擬頁映射到物理頁。


頁表可以有許多不同的結構，並且經過高度優化，因為在頁表中查找頁的過程可能是一個很長的過程。稍後我們將更深入地研究頁表。


進程的頁表由操作系統獨占控制。當進程請求內存時，操作系統會發現它是一個物理內存的免費頁面，並在進程頁表中記錄虛擬到物理的轉換。相反，當進程放棄內存時，將刪除虛擬到物理的記錄，底層框架將免費分配給另一個進程。


## 虛擬地址

當程序訪問內存時，它不知道或不關心支持地址的物理內存存儲在哪裡。它知道由操作系統和硬件共同工作來定位正確的物理地址，從而提供對它想要的數據的訪問。因此，我們將程序用來訪問內存的地址稱為虛擬地址。虛擬地址由兩部分組成;頁和一個偏移到該頁的偏移量。


### 頁面

由於整個可能的地址空間被劃分為普通大小的頁面，所以每個可能的地址都駐留在一個頁面中。虛擬地址的頁面組件充當進入頁表的索引。由於頁面是系統內內存分配的最小單位，因此需要在使頁面非常小(從而有很多頁供操作系統管理)和使頁面更大(但可能會浪費內存)之間進行權衡


### 抵消

虛擬地址的最後一個位稱為偏移量，偏移量是您想要的字節地址和頁面開頭之間的位置差。在偏移量中需要足夠的位才能到達頁面中的任何字節。對於4K頁面，需要(4K ==(4 * 1024) == 4096 == 212 ==) 12位偏移。請記住，操作系統或硬件處理的最小內存數量是一個頁面，因此這4096字節中的每一個都駐留在一個頁面中，並作為“one”處理。


### 虛擬地址轉換

虛擬地址轉換是指查找哪個物理頁面映射到哪個虛擬頁面的過程。


在將虛擬地址轉換為物理地址時，我們只處理頁碼。這個過程的本質是獲取給定地址的頁碼，並在page-table中查找它，以找到一個指向物理地址的指針，並將虛擬地址的偏移量添加到物理地址，從而給出系統內存中的實際位置。


由於頁表由操作系統控制，如果頁表中不存在虛擬地址，則操作系統知道進程正在嘗試訪問未分配給它的內存，並且不允許訪問。


> 圖6.3。虛擬地址轉換

![](http://www.bottomupcs.com/chapter05/figures/virtaddress.png)

> 將虛擬地址轉換為物理地址



我們可以通過前面簡單的線性頁表的例子來理解這一點。我們計算出，在使用4KiB頁面時，32位地址空間需要一個包含1048576個條目的表。因此，要映射理論地址0x80001234，第一步是刪除偏移位。在這種情況下，對於4KiB頁面，我們知道我們有12位(2<sup>12</sup> == 4096)的偏移量。所以我們可以右移出虛擬地址的12位，只留下0x80001。因此(十進制)線性頁表的第524289行中的值將是與該頁相對應的物理框架。


您可能會看到線性頁表的問題:因為必須考慮到每個頁面，無論是否在使用，物理線性頁表對於64位地址空間是完全不切實際的。假設一個64位的地址空間被分割成(相當大)64個KiB頁面創建2<sup>64</sup>/2<sup>12</sup> = 252頁面要管理;假設每個頁面都需要一個指向物理位置的8字節指針，那麼對於頁面表來說，總共需要2<sup>52</sup>/2<sup>3</sup> = 2<sup>49</sup>或512 GiB的連續內存!


### 虛擬地址、頁面和頁表的結果

虛擬地址、頁面和頁表是每個現代操作系統的基礎。它支撐著我們使用系統的大部分事情。


### 個人地址空間

通過為每個進程提供它自己的頁表，每個進程都可以假裝它可以訪問處理器可用的整個地址空間。兩個進程可能使用相同的地址並不重要，因為每個進程的不同頁表將把它映射到不同的物理內存框架。每個現代操作系統都為每個進程提供了自己的地址空間。


隨著時間的推移，物理內存變得支離破碎，這意味著物理內存中存在自由空間的“漏洞”。在這些漏洞周圍工作最多只會讓人討厭，而且會成為程序員的一個嚴重限制。例如，如果你有8kib的內存;如果需要兩個4 KiB幀的支持，如果這些幀必須是連續的(即)。使用虛擬地址並不重要;就進程而言，它有8千字節的連續內存，即使這些頁面是由相隔很遠的幀支持的。通過為每個進程分配虛擬地址空間，程序員可以將圍繞碎片的工作留給操作系統。


### 保護

我們之前提到過，386處理器的虛擬模式稱為受保護模式，這個名稱源於虛擬內存可以為在其上運行的進程提供的保護。


在沒有虛擬內存的系統中，每個進程都可以完全訪問所有的系統內存。這意味著沒有什麼可以阻止一個進程覆蓋另一個進程內存，導致它崩潰(或者更糟，返回不正確的值，特別是如果該程序正在管理您的銀行帳戶!)


提供這種級別的保護是因為操作系統現在是進程和內存訪問之間的抽像層。如果一個進程提供了一個不在其頁面表中覆蓋的虛擬地址，那麼操作系統就知道這個進程做錯了什麼，並且可以通知它已經超出了界限的進程。


由於每個頁面都有額外的屬性，因此可以只設置一個頁面的讀、寫或其他感興趣的屬性。當進程試圖訪問頁面時，操作系統可以檢查它是否有足夠的權限，如果沒有，就會停止它(例如，寫入只讀頁面)。


使用虛擬內存的系統本質上更穩定，因為假設有完美的操作系統，進程只能自己崩潰，而不是整個系統 (當然，人類編寫操作系統，我們不可避免地忽略了仍然會導致整個系統崩潰的bug)。

### 交換

我們現在還可以看到交換內存是如何實現的。如果不指向系統內存的某個區域，可以將頁面指針更改為指向磁盤上的某個位置。


當引用此頁面時，操作系統需要將其從磁盤移回系統內存(記住，程序代碼只能從系統內存執行)。如果系統內存已滿，則需要將另一個頁面踢出系統內存並將其放入交換磁盤，然後才能將所需的頁面放入內存中。如果另一個進程想要重新刪除剛剛被刪除的頁面，該進程會重復。


這可能是交換內存的一個主要問題。從硬盤加載是非常緩慢的(與在內存中進行的操作相比)，大多數人將熟悉坐在電腦前，而硬盤攪拌，而系統仍然沒有響應。


###  mmap

另一個不同但相關的進程是內存映射，或mmap(來自系統調用名稱)。如果不是指向物理內存的頁表，或者交換指向磁盤上文件的頁表，我們說文件是mmaped。


通常，您需要打開磁盤上的文件以獲得文件描述符，然後以順序的形式讀寫它。當一個文件被mmaped時，它可以像系統RAM一樣被訪問。


### 共享內存

通常，每個進程都有自己的頁表，因此它使用的任何地址都映射到物理內存中的唯一幀。但是，如果操作系統將兩個頁面表項指向相同的框架呢?這意味著這個框架將被共享;一個過程所做的任何改變對另一個過程都是可見的。


現在您可以看到線程是如何實現的。在名為“clone”的部分中，我們說Linux clone()函數可以根據需要與舊進程共享盡可能多或盡可能少的新進程。如果一個進程調用clone()來創建一個新的進程，但是請求兩個進程共享同一個頁面表，那麼當兩個進程看到相同的底層物理內存時，就會有一個線程。


現在您還可以看到如何完成寫操作。如果將頁面的權限設置為只讀，當進程試圖寫入頁面時，操作系統將被通知。如果它知道這個頁面是一個寫時復制的頁面，那麼它需要在系統內存中重新復制這個頁面，並將頁表中的頁指向這個新頁面。然後，可以更新它的屬性以具有寫權限，並且進程擁有自己的頁面副本。


### 磁盤緩存

在現代系統中，通常情況下，內存不是太少，而是需要交換內存，可用內存比系統當前使用的要多。


內存層次結構告訴我們，磁盤訪問要比內存訪問慢得多，因此盡可能多地將數據從磁盤移動到系統內存中是有意義的。


Linux和許多其他系統在使用時將把磁盤上的文件中的數據復制到內存中。即使程序最初只請求文件的一小部分，在繼續處理時，它很可能希望訪問文件的其余部分。當操作系統必須讀寫文件時，它首先檢查文件是否在其內存緩存中。


當系統中的內存壓力增加時，這些頁面應該首先被刪除。


### 頁面緩存

在討論內核時，您可能會聽到一個術語:頁面緩存。


頁面緩存指的是內核保存的引用磁盤上文件的頁面列表。從上面看，交換頁、mmaped頁和磁盤緩存頁都屬於這一類。內核之所以保留這個列表，是因為它需要能夠快速查找這些列表，以響應讀和寫請求

<!-- XXX:這個位不文件? -->


## 的硬件支持

到目前為止，我們只提到了硬件與操作系統一起工作以實現虛擬內存。然而，我們掩蓋了這一切是如何發生的細節。


虛擬內存必須非常依賴於硬件架構，並且每個架構都有自己的微妙之處。然而，在硬件中有一些通用的虛擬內存元素。


### 物理v虛擬模式

所有處理器都有一些在物理模式或虛擬模式下運行的概念。在物理模式下，硬件期望任何地址都會引用實際系統內存中的地址。在虛擬模式下，硬件知道需要翻譯地址才能找到它們的物理地址。


在許多處理器中，這兩種模式被簡單地稱為物理模式和虛擬模式。安騰就是這樣一個例子。最常見的處理器x86在虛擬內存出現之前就有很多負擔，因此這兩種模式被稱為真實模式和保護模式。實現受保護模式的第一個處理器是386處理器，即使是x86家族中最現代的處理器也可以實現真正的模式，盡管它沒有被使用。在實際模式下，處理器實現一種內存組織形式，稱為分段。

### 分割問題

分割實際上只是作為歷史注釋才有趣，因為虛擬內存使它不那麼相關。分割有許多缺點，其中最重要的是它對沒有經驗的程序員來說是非常令人困惑的，虛擬內存系統的發明主要是為了解決這個問題。


在分段中有許多寄存器，它們包含一個地址，這是段的開始。在內存中訪問地址的唯一方法是將其指定為這些段寄存器之一的偏移量。段的大小(因此可以指定的最大偏移量)是由段基寄存器的可用偏移量決定的。在x86系統中，最大偏移量是16位，即只有64K[18]。如果一個人想要使用距離超過64K的地址，這會造成各種各樣的破壞，隨著內存增長到兆字節(現在是十億字節)，這對完全失敗來說不僅僅是一個小麻煩。


>圖6.4。分割

![](http://www.bottomupcs.com/chapter05/figures/segmentation.png)

> 一個分割問題。您只有三個段寄存器，並且只能從每個段偏移一小段距離。你怎樣才能到達另一個地址?您需要手動重新組織段寄存器，這會很快成為瓶頸。



在上圖中，有三個段寄存器都指向段。最大偏移量(受可用比特數的限制)由著色顯示。如果程序需要超出此範圍的地址，則必須重新配置段寄存器。這很快就成為一個大麻煩。另一方面，虛擬內存允許程序指定任何地址，操作系統和硬件完成轉換為物理地址的艱苦工作。


###  TLB

轉換後備緩衝區(簡稱TLB)是負責虛擬內存的處理器的主要組件。它是處理器內部物理幀轉換的虛擬頁緩存。操作系統和硬件協同工作，在系統運行時管理TLB。


### 頁面錯誤

當硬件請求虛擬地址時(例如通過請求獲取數據的加載指令)，處理器在TLB中查找虛擬地址到物理地址的轉換。如果它有一個有效的轉換，那麼它可以將它與偏移量部分結合起來，直接到物理地址並完成加載。


但是，如果處理器無法在TLB中找到轉換，那麼處理器必須引發頁面錯誤。這類似於操作系統必須處理的中斷(如前所述)。


當操作系統出現頁面錯誤時，它需要遍歷頁面表以找到正確的翻譯並將其插入TLB。


如果操作系統在頁表中找不到翻譯，或者操作系統檢查了所討論的頁面的權限，而進程沒有被授權訪問，操作系統必須終止該進程。如果您曾經看到過分段錯誤(或分段錯誤)，這是操作系統殺死一個超出其界限的進程。


如果找到了翻譯，並且TLB當前已滿，那麼在插入另一個翻譯之前，需要刪除一個翻譯。刪除可能在將來使用的翻譯是沒有意義的，因為您將再次在頁表中查找條目的開銷。TLBs通常使用一些最近使用最少的方法或LRU算法，在這種方法中，沒有使用的最古老的轉換將被排除在新的轉換之外。


然後可以再次嘗試訪問，如果一切順利，應該在TLB中找到並正確翻譯。


### 找到頁表

當我們說操作系統在頁表中找到轉換時，詢問操作系統如何找到包含頁表的內存是合乎邏輯的。


頁表的基將保存在與每個進程相關聯的寄存器中。這通常稱為頁表基寄存器或類似的寄存器。通過獲取此寄存器中的地址並向其添加頁碼，就可以找到正確的條目。
其他頁面相關錯誤

TLB通常會生成兩個其他重要的錯誤，它們有助於管理訪問的頁面和髒頁面。每個頁面通常都包含一個以單個位形式表示的屬性，如果頁面被訪問或髒了，該屬性就會標記出來。


被訪問的頁面就是任何被訪問的頁面。當最初將頁面轉換加載到TLB時，頁面可以被標記為已訪問(否則為什麼要將其加載到[19]中?)


操作系統可以周期性地遍歷所有頁面並清除所訪問的位，以了解當前正在使用的頁面。當系統內存滿了，操作系統需要選擇將頁面交換到磁盤時，顯然那些訪問位沒有被重置的頁面是最適合刪除的，因為它們使用的時間不是最長的。


髒頁面是一個有數據寫入的頁面，因此不匹配磁盤上已經存在的任何數據。例如，如果一個頁面從swap加載，然後被一個進程寫入，在它可以從swap移出之前，它需要在磁盤上更新它的副本。一個干淨的頁面沒有任何更改，所以我們不需要將頁面復制回磁盤的開銷。


它們都類似於幫助操作系統管理頁面。一般的概念是一個頁面有兩個額外的位;髒位和訪問位。當將頁面放入TLB時，這些位被設置為表示CPU應該引發錯誤。


當進程嘗試引用內存時，硬件執行通常的轉換過程。不過，它還會額外檢查訪問的標志是否沒有設置。如果設置了，它會給操作系統帶來錯誤，操作系統應該設置位並允許進程繼續。類似地，如果硬件檢測到它正在寫入一個沒有髒位集的頁面，它將導致操作系統將頁面標記為髒的錯誤。


###  TLB管理

我們可以說，TLB由硬件使用，但由軟件管理。用正確的條目加載TLB並刪除舊條目，這取決於操作系統。


### 刷新TLB

從TLB中刪除條目的過程稱為刷新。更新TLB是維護進程獨立地址空間的關鍵部分;因為每個進程可以使用相同的虛擬地址沒有更新TLB意味著一個進程可能會覆蓋另一個進程內存(相反,在線程中共享地址空間是你想要的,因此,TLB不刷新線程之間切換時相同的過程)。


在某些處理器上，每當有上下文切換時，整個TLB都會被刷新。這可能會非常昂貴，因為這意味著新過程必須經歷整個過程，即獲取頁面錯誤、在頁表中查找頁面並插入翻譯。


其他處理器實現一個額外的地址空間ID (ASID)，該ID被添加到每個TLB轉換中以使其唯一。這意味著每個地址空間(通常是每個進程，但是要記住線程希望共享相同的地址空間)都有自己的ID，它與TLB中的任何轉換一起存儲。因此，在上下文切換時，TLB不需要刷新，因為下一個進程將具有不同的地址空間ID，即使它請求相同的虛擬地址，地址空間ID也會不同，因此轉換到物理頁面的方式也會不同。這種方案減少了刷新，提高了系統的整體性能，但是需要更多的TLB硬件來容納ASID位。


通常，這是通過有一個額外的寄存器作為包括ASID的進程狀態的一部分來實現的。當執行虛擬到物理的轉換時，TLB查詢這個寄存器，並且只匹配那些與當前運行的進程具有相同ASID的條目。當然，這個寄存器的寬度決定了ASID可用的數量，因此具有性能影響。有關處理器體系結構中的ASID的示例，請參閱“地址空間”一節。

### 硬件v軟件加載TLB

而TLB中的控制是操作系統的領域;這並不是故事的全部。在“頁面錯誤”一節中描述的過程描述了操作系統中出現的頁面錯誤，操作系統遍歷頁面表以找到虛擬到物理的轉換，並將其安裝到TLB中。這將被稱為軟件加載的TLB——但還有另一種選擇;的hardware-loaded TLB。


在硬件加載的TLB中，處理器體系結構定義了頁表信息的特定布局(稱為“頁+幀=頁表”的部分，在進行虛擬地址轉換時必須遵循該部分。為了響應對TLB中不存在的虛擬地址的訪問，處理器將自動遍歷頁表以加載正確的翻譯條目。只有當翻譯條目不存在時，處理器才會引發一個由操作系統處理的異常。


在專用硬件中實現頁表遍歷在查找翻譯時具有速度優勢，但會使操作系統實現者失去靈活性，這些實現者可能希望為頁表實現替代方案。


所有架構都可以大致分為這兩種方法。稍後，我們將研究一些常見的體系結構及其虛擬內存支持。


假設最大偏移量為32位;在這種情況下，整個地址空間可以作為從0x00000000處的段的偏移量訪問，而且實際上會有一個平面布局——但它仍然不如您將看到的虛擬內存好。事實上，它是16位的唯一原因是因為最初的英特爾處理器僅限於此，而且芯片保持向後兼容。


> [19] 事實上,如果你是在沒有加載等待訪問這個被稱為投機,這是你在哪裡做些什麼,期望將償還。例如,如果代碼閱讀記憶線性把下一頁的翻譯在TLB可能節省時間和性能改進。


##  Linux細節


雖然虛擬內存的基本概念保持不變，但是實現的細節高度依賴於操作系統和硬件。


### 地址空間布局

Linux將可用的地址空間劃分為共享的內核組件和私有用戶空間地址。這意味著地址空間內核端口中的地址映射到每個進程的相同物理內存，而用戶空間地址是進程的私有地址。在Linux上，共享內核空間位於可用地址空間的頂端。在最常見的32位x86處理器上，這種分離發生在3GB點。由於32位可以映射最多4GB，所以共享內核區域[20]的最大1GB空間就剩下了。


> 圖6.5。Linux地址空間布局
![](http://www.bottomupcs.com/chapter05/figures/linux-layout.png)

> Linux地址空間布局。注意，用戶空間地址空間中的頁面是私有的，而內核頁面是共享的。



### 三層頁面表

操作系統有許多不同的方式來組織頁表，但是Linux選擇使用層次系統。


由於頁表使用深度為三層的層次結構，Linux方案通常稱為三層頁表。三層頁面表已被證明是健壯的選擇，盡管它並非沒有批評。每個處理器的虛擬內存實現的詳細信息不同於Whitley，這意味著Linux選擇的通用頁表必須是可移植的和相對通用的。


三層頁面表的概念並不難。我們已經知道虛擬地址由頁號和物理內存頁中的偏移量組成。在一個三層的頁面表中，虛擬地址被進一步劃分為若干層。


每一層都是屬於自己的一頁表;例如，它映射一個物理頁面的頁碼。在單個級別頁面表中，“level 1”條目將直接映射到物理框架。在多層版本中，每個上層都給出了物理內存幀的地址，該地址包含下一層的頁表。


> 圖6.6。Linux三級頁表


![](http://www.bottomupcs.com/chapter05/figures/threelevel.png)


> 一個三級頁表



因此，示例引用涉及到訪問頂層頁表，找到下一層地址所在的物理框架，讀取該層表並找到下一層頁表所在的物理框架，等等。


首先，這個模型似乎是不必要的復雜。實現此模型的主要原因是考慮到大小。想像一下一個進程的理論情況，在它的虛擬地址空間的末尾只有一個單獨的頁面映射。我們之前說過，頁表條目是作為頁表基寄存器的偏移量找到的，因此頁表需要是內存中的連續數組。因此，地址空間末尾的單個頁面需要整個數組，這可能會占用相當大的空間(許多、許多物理頁面的內存)。


在一個三級系統中，第一級僅僅是一個物理內存框架。這將映射到第二層，這又是一個單一的內存框架，又是第三層。因此，三級系統將所需頁面數量減少到單個級別系統所需頁面數量的一小部分。


這個制度有明顯的缺點。查找單個地址需要更多的引用，這可能很昂貴。Linux知道，這個系統可能不適用於許多不同類型的處理器，因此每個體系結構都可以折疊頁表以輕松地減少級別(例如，最常見的體系結構x86在其實現中只使用一個二級系統)。


> 遺憾的是，這是一種過於簡化的方法，因為許多機器希望支持每個進程超過4GB。高內存支持允許處理器通過特殊擴展訪問完整的4GB。


### 對虛擬內存的硬件支持


如“TLB”一節所述，處理器硬件提供了一個查找表，將虛擬地址與物理地址鏈接起來。每個處理器體系結構都定義了不同的方法來管理TLB，有不同的優點和缺點。


處理虛擬內存的處理器部分通常稱為內存管理單元或MMU

<!--
### x86-64

XXX
-->

### 安騰

Itanium MMU為操作系統提供了許多有趣的特性來處理虛擬內存。


### 地址空間

名為“刷新TLB”的部分引入了地址空間ID的概念，以減少在上下文切換時刷新TLB的開銷。然而，程序員經常使用線程來允許執行上下文共享地址空間。每個線程都具有相同的ASID，因此共享TLB條目，從而提高了性能。然而，一個單獨的ASID阻止TLB執行保護;分享成為一種“要麼全部要麼沒有”的方法。為了共享甚至幾個字節，線程必須放棄彼此之間的所有保護(參見“保護”一節)。


> 圖6.7。說明安騰區域和保護鍵


![](http://www.bottomupcs.com/chapter05/figures/ia64-regions-keys.png)


> 安騰區域和保護鍵。在本例中，流程別名區域1。每個進程都有一個私有映射，它們為另一個進程共享一個密鑰。


Itanium MMU考慮到了這些問題，並提供了以更低的粒度共享地址空間(以及翻譯條目)的能力，同時仍然在硬件中維護保護。Itanium將64位地址空間劃分為8個區域，如圖6.7所示，“插圖Itanium區域和保護鍵”。每個進程都有8個24位區域寄存器作為其狀態的一部分，每個區域都為進程地址空間的8個區域中的每個區域持有一個區域ID (RID)。TLB翻譯被標記為RID，因此只有當進程也持有這個RID時才會匹配，如圖6.8所示，“Itanium TLB翻譯的插圖”。


> 圖6.8。Itanium TLB翻譯插圖


> 說明的Itanium翻譯過程(Mosberger)。


![](http://www.bottomupcs.com/chapter05/figures/ia64-tlb-translation.png)


此外，在虛擬地址轉換中不考慮前三位位(區域位)。因此，如果兩個進程共享RID(即，在其中一個區域寄存器中保持相同的值)，然後對該區域進行別名視圖。例如，如果process-A在寄存器3中持有RID 0x100, process-B在寄存器5中持有相同的RID 0x100，那麼process-A，區域3別名為process-B，區域5。這種有限的共享意味著兩個進程都可以獲得共享TLB條目的好處，而不必授予對它們整個地址空間的訪問權。


### 保護密鑰

為了允許更細粒度的共享，Itanium上的每個TLB條目也都標有保護鍵。每個進程在操作系統控制下都有額外的保護密鑰寄存器。


當要共享一系列頁面(例如，共享系統庫的代碼)時，每個頁面都被標記為唯一鍵，操作系統授予任何進程訪問該鍵的頁面的權限。當一個頁面被引用時，TLB將根據進程保存在其保護密鑰寄存器中的密鑰檢查與轉換條目相關的密鑰，如果密鑰存在，則允許訪問該密鑰，否則將導致操作系統出現保護故障。


密鑰還可以強制權限;例如，一個進程可能有授予寫權限的鍵，另一個進程可能有只讀鍵。這允許在更廣泛的情況下共享翻譯條目，粒度精確到單頁級別，導致TLB性能的巨大潛在改進。


### Itanium硬件頁表步行者

在解決TLB丟失時，將上下文切換到操作系統會給故障處理路徑增加大量開銷。為了解決這個問題，Itanium允許使用內置硬件來讀取頁表，並自動將虛擬到物理的轉換加載到TLB中。硬件頁表walker (HPW)避免了昂貴的操作系統轉換，但要求轉換為適合硬件理解的固定格式。


Itanium HPW在英特爾的文檔中被稱為實際上散列的頁表步行者或VHPT步行者，其原因應該變得很清楚。Itanium給了開發人員兩個相互排斥的HPW實現的選擇;一個基於虛擬線性頁表，另一個基於哈希表。


應該注意的是，它是可能的操作沒有硬件頁表步行者;在這種情況下，每個TLB丟失都由操作系統解決，處理器變成了一個裝載軟件的體系結構。然而，禁用HPW對性能的影響非常大，因此這樣做不太可能獲得任何好處

### 虛擬線性頁表

在文檔中，虛擬線性頁表實現被稱為短格式虛擬散列頁表(SF-VHPT)。它是Itanium上的Linux使用的默認HPW模型。


通常的解決方案是多層次或層次化的頁表，其中包含虛擬頁號的位被用作頁表中間層的索引(參見“三層頁表”一節)。虛擬地址空間的空白區域根本不存在於分層頁面表中。與線性頁表相比，對於緊密集群和稀疏填充的地址空間(實際情況)，相對較少的空間浪費在開銷上。主要的缺點是查找需要多個內存引用。


> 圖6.9。分層頁表的插圖


![](http://www.bottomupcs.com/chapter05/figures/ia64-tlb-translation.png)


> 層次頁面表



對於64位的地址空間，即使是在名為“虛擬地址轉換”的部分中確定的512~GiB線性表，也只占用16 eb可用數據的0.003%。因此，可以在一個連續的虛擬地址空間中創建一個虛擬線性頁表(VLPT)。


就像物理上的線性頁表一樣，在TLB上，硬件使用虛擬頁號來偏移頁表基。如果該條目有效，則讀取並直接插入TLB。然而，使用VLPT，翻譯條目的地址本身就是一個虛擬地址，因此它所在的虛擬頁面可能不在TLB中。在這種情況下，操作系統會出現嵌套故障。然後，軟件必須通過將保存翻譯條目的頁面映射到VLPT來糾正這個錯誤。


> 圖6.10。Itanium短格式VHPT實現


![](http://www.bottomupcs.com/chapter05/figures/ia64-short-format.png)


### Itanium短格式VHPT的操作



如果操作系統保持一個層次化的頁表，這個過程可以很直接地進行。層次化頁表的頁頁包含一個幾乎連續的地址區域的翻譯條目，因此TLB可以通過映射來創建VLPT，如圖6.10所示，“Itanium短格式VHPT實現”。


> 圖6.11。Itanium PTE錄入格式


> Itanium PTE錄入格式


![](http://www.bottomupcs.com/chapter05/figures/ia64-ptes.png)


VLPT的主要優點是當應用程序對內存進行重復或連續訪問時。考慮到對虛擬連續內存的遍歷，第一個錯誤將把一個滿是翻譯條目的頁面映射到虛擬線性頁表。對下一個虛擬頁面的後續訪問將需要將下一個翻譯條目加載到TLB, TLB現在可以在VLPT中使用，因此加載速度非常快，無需調用操作系統。總的來說，如果初始嵌套故障的成本在隨後的HPW命中被攤銷，這將是一個優勢。


主要的缺點是VLPT現在需要TLB條目，這會增加TLB壓力。由於每個地址空間都需要自己的頁表，因此隨著系統變得更加活躍，管理費用也會越來越高。然而，任何TLB容量缺失的增加都應該比高效硬件步行者在更低的重新填充成本中恢復的多。請注意,病理情況下可以跳過頁大小÷translation_size條目,造成重復嵌套的缺點,但這是一個非常可能訪問模式。


硬件walker希望轉換條目采用特定的格式，如圖6.11左邊所示，“Itanium PTE條目格式”。VLPT需要所謂的8字節短格式的翻譯。如果操作系統要使用它的頁表作為VLPT的支持(如圖6.10所示，“Itanium短格式VHPT實現”)，它必須使用這種翻譯格式。該體系結構描述了這種格式中有限的比特數，因此可以被軟件使用，但不可能進行重大修改。


線性頁表是以固定頁面大小為前提的。多頁面大小的支持是有問題的，因為這意味著對給定虛擬頁面的轉換不再是固定的偏移量。為了解決這個問題，地址空間的8個區域(圖6.7，“插圖Itanium區域和保護鍵”)都有一個單獨的VLPT，它只映射該區域的地址。可以為每個區域提供默認的頁面大小(實際上，使用下面討論的Linux HugeTLB，一個區域專門用於更大的頁面)。然而，頁面大小不能在一個區域內混合。

#### 虛擬哈希表

使用TLB條目來減少TLB重新填充成本，就像SF-VHPT所做的那樣，可能是也可能不是一種有效的權衡。Itanium還實現了一個散列頁面表，具有降低TLB開銷的潛力。在這種方案中，處理器對虛擬地址進行哈希，以找到相鄰表中的偏移量。


前面描述的物理線性頁表可以認為是一個哈希頁表，具有完美的哈希函數，不會產生衝突。然而，正如所解釋的那樣，這需要對大量連續物理內存進行不切實際的權衡。但是，限制頁表的內存需求會增加兩個虛擬地址哈希到相同偏移量時發生衝突的可能性。碰撞翻譯需要一個鏈指針來構建一個鏈鏈表，鏈鏈表是可選的可能條目。要區分鏈接列表中的哪個條目是正確的，需要從傳入的虛擬地址派生一個標記。


每個翻譯條目所需的額外信息導致了綽號長格式~VHPT (LF-VHPT)。翻譯條目增長到32字節，如圖6.11“Itanium PTE條目格式”右側所示。


這種方法的主要優點是全局哈希表可以用單個TLB條目固定。由於所有進程共享表，因此它的伸縮性應該比SF-VHPT更好，SF-VHPT需要增加VLPT頁面的TLB條目數。但是，大條目的緩存友好性較差;考慮到我們可以為每個32字節的長格式條目容納4個8字節的短格式條目。然而，Itanium處理器上的超大緩存可能有助於減輕這種影響。


SF-VHPT的一個優點是，操作系統可以將翻譯保存在分層的頁表中，並且只要保持硬件翻譯格式，就可以將頁直接映射到VLPT。對於LF-VHPT，操作系統必須使用哈希表作為翻譯條目的主要來源，或者將哈希表作為其自身翻譯信息的緩存。將LF-VHPT哈希表作為緩存有點不太理想，因為在關鍵故障路徑上增加了開銷，但是只需要一個TLB條目的表可以獲得優勢。