第 8 章 调度：多级反馈队列

1962 年，Corbato 首次提出多级反馈队列[C+62]，应用于兼容时分共享系统（CTSS）。Corbato 因在 CTSS 中的贡献和后来在 Multics 中的贡献，获得了 ACM 颁发的图灵奖（TuringAward）。该调度程序经过多年的一系列优化，出现在许多现代操作系统中。

像轮转这样的算法虽然降低了响应时间，周转时间却很差。

## 关键问题：没有完备的知识如何调度？

没有工作长度的先验（priori）知识，如何设计一个能同时减少响应时间和周转时间的调度程序？

提示：从历史中学习

多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。

## 8.1 MLFQ：基本规则

MLFQ 中有许多独立的队列（queue），每个队列有不同的优先级（priority level）。任何时刻，一个工作只能存在于一个队列中。MLFQ 总是优先执行较高优先级的工作（即在较高级队列中的工作）。

当然，每个队列中可能会有多个工作，因此具有同样的优先级。在这种情况下，我们就对这些工作采用轮转调度。

因此，MLFQ 调度策略的关键在于如何设置优先级。MLFQ 没有为每个工作指定不变的优先，而是根据观察到的行为调整它的优先级。例如，如果一个工作不断放弃CPU 去等待键盘输入，这是交互型进程的可能行为，MLFQ 因此会让它保持高优先级。相反，如果一个工作长时间地占用 CPU，MLFQ 会降低其优先级。通过这种方式，MLFQ 在进程运行过程中学习其行为，从而利用工作的历史来预测它未来的行为。

* 规则 1：如果 A 的优先级 > B 的优先级，运行 A（不运行 B）。
* 规则 2：如果 A 的优先级 = B 的优先级，轮转运行A 和 B。

## 8.2 尝试 1：如何改变优先级 

* 规则 3：工作进入系统时，放在最高优先级（最上层队列）。
* 规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）。
* 规则 4b：如果工作在其时间片以内主动释放 CPU，则优先级不变

实例 1：单个长工作 
实例 2：来了一个短工作
实例 3：如果有 I/O 呢 

## 8.3 尝试 2：提升优先级

## 8.4 尝试 3：更好的计时方式

* 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。
* 规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。

## 8.5 MLFQ 调优及其他问题 