# 第 6 章 机制：受限直接执行

直接执行: 指在 CPU 上直接執行，而不是透過解譯之類的間接執行動作。

关键问题：如何执行受限制的操作

一个进程必须能够执行 I/O 和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？

提示：采用受保护的控制权转移

## trap -- 從用戶模式轉給作業系統

硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。


例如，在 x86 上，处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈（kernel stack）上。从返回陷阱将从栈弹出这些值，并恢复执行用户模式程序（有关详细信息，请参阅英特尔系统手册[I11]）。其他硬件
系统使用不同的约定，但基本概念在各个平台上是相似的。

## 作業系統與應用程式的交互過程

```
操作系统@启动（内核模式）       硬件                      程序（应用模式）
初始化陷阱表
                            记住系统调用处理程序的地址

在进程列表上创建条目
为程序分配内存
将程序加载到内存中
根据 argv 设置程序栈
用寄存器/程序计数器填充内核栈
从陷阱返回

                            从内核栈恢复寄存器
                            转向用户模式
                            跳到 main
                                                        运行 main
                                                        ……
                                                        调用系统调用
                                                        陷入操作系统
                            将寄存器保存到内核栈
                            转向内核模式
                            跳到陷阱处理程序
处理陷阱
做系统调用的工作
从陷阱返回

                            从内核栈恢复寄存器
                            转向用户模式
                            跳到陷阱之后的程序计数器
                                                        ……从 main 返回
                                                        陷入（通过 exit()）
释放进程的内存将进程
从进程列表中清除
```

## 关键问题：如何在没有协作的情况下获得控制权

即使进程不协作，操作系统如何获得 CPU 的控制权？操作系统可以做什么来确保流氓进程不会占用机器？

提示：利用时钟中断重新获得控制权

即使进程以非协作的方式运行，添加时钟中断（timer interrupt）也让操作系统能够在 CPU 上重新运行。因此，该硬件功能对于帮助操作系统维持机器的控制权至关重要。